# MetCE
MetCE is a platform for processing LC-MS/MS data for chemical ecology. It gets input from MZMine and SIRIUS. The major toolboxes of MetCE are as follows:
<img width="1921" height="1080" alt="Screenshot 2025-07-24 at 6 59 47â€¯PM" src="https://github.com/user-attachments/assets/517b33f9-7b66-4067-bda8-a66ae0a1d99c" />


## 0. Input
Following input files would be imported. See '/raw_data' of demo files.
1) Feature quantification table generated by MZMine4 (`mzmine_feature.csv`)
2) Annotation of features by SIRIUS (`canopus_formula_summary.tsv` and `structure_identification.tsv`)
3) Metadata of samples (`metadata.csv`)
	Metadata should have three or more columns; the first three being sample, group, and mass. Additional information can be provided (see performance_regression part).
4) (Optional) Custom annotation of features ('custom_DB_glucosinolates.csv')
	The custom DB includes three columns: 
5) (Optional) Pairwise fingerprint distance of features from PyQemistree (`fingerprint_distance.csv`)
6) (Optional) Pairwise modified cosine distances of all spectra from MZMine 4 (`cossim_ms2_modified_cos.csv`)
	
The demo files are metabolomics analysis files of Arabidopsis thaliana (Col-0) attacked by three different herbivores (Spodoptera litura; sl, Plutella xylostella; px, and Lipaphis erysimi; le) in three different degree of attack. Which makes 10 groups (con, sl1, sl2, sl3, px1, px2, px3, le1, le2, and le3). Six replicates were sampled and analyzed for each group. See metadata.csv for more details. 

## 1. Initializing the MMO object
All input files are imported to construct a `mmo` object. The `mmo` object will be used in downstream statistics.
```
#Give directories
mzmine_featuredir <- 'raw_data/mzmine_feature.csv'
metadatadir <- "raw_data/metadata.csv"
canopus_formuladir <- "raw_data/canopus_formula_summary.tsv"
canopus_structuredir <- "raw_data/structure_identifications.tsv"
qemistry_dir <- 'raw_data/fingerprint_distance.csv'
cos.sim.dir <- 'raw_data/modified_cos_similarity.csv'
```
First import the mzmine feature list and metadata to create a `mmo` object.

`mmo <- GetMZmineFeature(mzmine_featuredir, metadatadir)`

then add annotation generated from sirius to the object

`mmo <- AddSiriusAnnot(mmo, canopus_structuredir, canopus_formuladir)`

then replace zero values for further statistics.

`mmo <- ReplaceZero(mmo, method = 'one') # Replace 0 and NA values by half of the minimum value`

then normalize using sample mass used for extraction

`mmo <- MassNormalization(mmo) # Normalize peak area by sample mass in metadata`

then generate various normalized through mean-centering, log, and z-score.
```
mmo <- MeancenterNormalization(mmo) # Add mean-centered area
mmo <- LogNormalization(mmo) # Add log-transformed area
mmo <- ZNormalization(mmo) # Add Zscore
```
Custom annotation can be added based on m/z and RT.
`mmo <- AddCustomDB(mmo, )`
Fingerprint distance and cosine distance can be added.
```
qemistree <- read.csv(qemistry_dir, row.names = 1, header = TRUE, check.names = FALSE) # Load qemistree distance matrix
mmo$qemistree <- qemistree # Add qemistree distance matrix to mmo object
mmo <- GetCosSimToDissim(mmo, cos.sim.dir) # Add cosine dissimilarity matrix to mmo object
```

### mmo object
The `mmo` object contains following information
1) Feature quantification value ($feature_data)
2) Metadata ($metadata)
3) Pairwise comparison data ($pairwise)
4) Log, mean-centered, and Z-transformed feature quantification value ($log, $meancentered, and #zscore)
5) Sirius annotation ($sirius_annot)
6) fingerprint distance ($qemistree)
7) cosine distance ($cos.dissim)

All features have id (from mzmine) and feature (mz_rt generated by GetMZmineFeature()). Both can be interchangable.
Since only a subset of features are annotated and used for qemistree, some analyses only uses such features.
```
siriused_ids <- rownames(mmo$qemistree)
siriused_features <- IDToFeature(mmo, siriused_ids)
```
### Annotated features by SIRIUS
Some feature groups may deserve particular interest. For the demo file, glucosinolates and flavonoids are. We can briefly annotate those metabolites using annotation from sirius. 
```
features <- mmo$sirius_annot
# Get list of glucosinolated using sirius annotation
GLSs <- features %>% filter(str_detect(features[[46]], "Glucosinolate")) %>% pull(feature)
# Get list of flavonoids using sirius annotation
FLVs <- features %>% filter(str_detect(features[[46]], "Flavonoid")) %>% pull(feature)
```

## 2. Summarise using PLS-DA
By using PLS-DA plot, the general distribution of metabolic profile of each sample and group can be visualized. 
For each group give colors
```
# For custom colors,
custom_colors <- c("con" = "#999999", "sl1" = "#c89c7d", "px1" = "#55a5d3", "px2" = "#2575a4", 
                   "px3" = "#00446c", "sl2" = "#eeb696", "sl3" = "#bc6129", "le1" = "#a4d069", 
                   "le2" = "#618a29", "le3" = "#386200")
# For automated colors,
custom_colors <- setNames(brewer.pal(length(unique(mmo$metadata$group)), "Set3"), unique(mmo$metadata$group))
```
Then plot PLS-DA

`PLSDAplot(mmo, custom_colors, topk = 0, outdir = 'plots/plsda.pdf', normalization = 'Z', filter_feature = FALSE, feature_list = NULL, filter_group = FALSE, group_list = NULL)`

The `topk` parameter can be adjusted to plot loadings of top features on the plot. The `normalization` can be `None`, `Log`, `Meancentered`, and `Z`.
If a subset of features are to be used for ploting, set `filter_feature = TRUE` then provide the list of features to the `feature_list`
If a subset of groups are to be plotted, set 'filter_group = TRUE' then provide the list of groups to the group_list.
```
# Glucosinolates for onlt sl groups
PLSDAplot(mmo, custom_colors, topk = 0, outdir = 'plots/plsda_GLS_sl.pdf', normalization = 'Z', filter_feature = TRUE, feature_list = GLSs, filter_group = TRUE, group_list = c('con', 'sl1', 'sl2', 'sl3'))
```

## 3. Pairwise Comparison (DAMs)
Many analyses targets to find **Differentially Accumulated Metabolites (DAMs; corresponding to the DEGs in transcriptomics)**. DAMs can be defined by thresholds of log2-fold change and adjusted p-value. Those two metrics are calculated by following code. Note that the divisor group is at the left.

`mmo <- PairwiseComp(mmo, 'con', 'sl1')`

By iterating this, the mmo object adds two columns per operation (log2FC and padj) for each comparison.

```
mmo <- PairwiseComp(mmo, 'con', 'sl2')
mmo <- PairwiseComp(mmo, 'con', 'sl3')
mmo <- PairwiseComp(mmo, 'con', 'px1')
mmo <- PairwiseComp(mmo, 'con', 'px2')
mmo <- PairwiseComp(mmo, 'con', 'px3')
mmo <- PairwiseComp(mmo, 'con', 'le1')
mmo <- PairwiseComp(mmo, 'con', 'le2')
mmo <- PairwiseComp(mmo, 'con', 'le3')
```
Then DAMs of each comparison can be extracted.
```
# Generate the list of comparisons automatically by looking up mmo$pairwise
comparison_columns <- colnames(mmo$pairwise)
log2FC_columns <- grep("log2FC", comparison_columns, value = TRUE)
comparisons <- unique(sub("log2FC", "", log2FC_columns))
comparisons <- sub("_$", "", comparisons)  # Remove trailing underscore from comparisons
# Make list of DAMs for up and downregulation for each comparison
DAMs_up <- list()
DAMs_down <- list()
for (comp in comparisons) {
  group1 <- strsplit(comp, "_vs_")[[1]][1]
  group2 <- strsplit(comp, "_vs_")[[1]][2]
  DAMs_up[[paste(comp, "up", sep = ".")]] <- filter(mmo$pairwise, get(paste(comp, "log2FC", sep = "_")) > 1 & get(paste(comp, "padj", sep = "_")) < 0.1)$feature
  DAMs_down[[paste(comp, "down", sep = ".")]] <- filter(mmo$pairwise, get(paste(comp, "log2FC", sep = "_")) < -1 & get(paste(comp, "padj", sep = "_")) < 0.1)$feature
}          
names(DAMs_up) <- paste(comparisons, "up", sep = ".")
names(DAMs_down) <- paste(comparisons, "down", sep = ".")
```
In the above example the cutoff for DAM was set for |log2FC| > 1 and adjusted p-value < 0.1 . The values can be adjusted.

## 4. Upset and Venn Diagram
How many features are overlapping and specific are the common questions following DAM analysis. It can be visualized by UpSet plot and Venn diagram.
The inputs for both are identical and can be prepared as following
```
UpsetInput <- list(
  sl1.up = DAMs_up$con_vs_sl1.up,
  sl2.up = DAMs_up$con_vs_sl2.up,
  sl3.up = DAMs_up$con_vs_sl3.up,
  px1.up = DAMs_up$con_vs_px1.up,
  px2.up = DAMs_up$con_vs_px2.up,
  px3.up = DAMs_up$con_vs_px3.up,
  le1.up = DAMs_up$con_vs_le1.up,
  le2.up = DAMs_up$con_vs_le2.up,
  le3.up = DAMs_up$con_vs_le3.up
)
```
Then can be plotted as following
`upset(fromList(UpsetInput), nsets=10, nintersects=20,order.by='freq', mainbar.y.label='Features in Set', line.size=1, point.size=4, shade.color='white', text.scale=1, show.numbers=FALSE)`
If groups of interest are within 4, then venn diagram can also be a good plotting.
`ggvenn(UpsetInput)`

## 5. Volcano plot
The pairwise comparion can be visualized by a volcano plot. Following code generates volcano plots for all comparison made in section 3.
```
for (comp in comparisons){
  VolcanoPlot(mmo, comp = comp, topk = 10, outdir = paste('plots/volcano_', comp, '.pdf', sep = ''))
}
```
## 6. Canopus enrichment analysis
Biological questions ask which class of chemical compounds are enriched in a set of compounds of interest (e.g., DAMs from above). This is analogue to the Gene Ontology enrichment analysis performed in transcriptomics. In MMO, NPC and Classyfire terms annotated by Canopus of SIRIUS are used to perform chemical class enrichment analysis of given list of features. The enrichment score of each term is calculated to plot the number of each term and the significance.
`CanopusAllLevelEnrichmentPlot(mmo, DAMs_up, pthr = 0.1, terms = 'all_terms', representation = 'greater', prefix = 'plots/canopus_enrichment')`
The above code generates one pdf plot and two csv files. The csv files contains the raw data of the enrichment analysis.

## 7. Qemistree and heatmap
A heatmap is a great way to visualize the whole metabolome. Typically the features are clustered by the distribution pattern but in qemistree the chemical similarity between features are visualized. For heatmap, following parameters can be determined.
```
filter_feature <- FALSE
feature_list <- GLSs # list of features to show in heatmap
filter_group <- FALSE
group_list <- c('con', 'sl1', 'sl2', 'sl3') # list of groups to show in heatmap
summarize <- 'mean' #mean or fold_change
control_group <- 'con' # if summarize is fold_change, control group should be defined
normalization <- 'Z' #None, Log, Meancentered, Z
distance <- 'cosine' #cosine or qemistree or combined
```
Then run following to generate heatmap (under writing...)
```

# 12.1. Process data for heatmap
# 12.1.1. Get summarized data (group mean or FC)
if (filter_group){
  group_means <- GetGroupMeans(mmo, normalization = normalization, filter = TRUE, filter_groups = group_list)
} else {
  group_means <- GetGroupMeans(mmo, normalization = normalization)
}
if (summarize == 'fold_change'){
  fold_change <- GetLog2FoldChange(group_means, control_group = control_group)
  heatmap_data <- fold_change
} else if(summarize == 'mean'){ 
  heatmap_data <- group_means
}
head(heatmap_data)
# 12.1.2. Filter features
# Determine distance metric
if (distance == 'qemistree'){
  distance_matrix <- mmo$qemistree
} else if (distance == 'cosine'){
  distance_matrix <- mmo$cos.dissim
} else if (distance == 'combined'){
  distance_matrix <- mmo$qemistree * mmo$cos.dissim
}
heatmap_data <- heatmap_data %>% filter(id %in% rownames(distance_matrix)) # get features with fingerprints
heatmap_data$con <- NULL # as we are looking at FC, all con are 0
# make matrix for heatmap
FC_matrix <- as.matrix(heatmap_data[,-1])
rownames(FC_matrix) <- heatmap_data$id
# Reorder the rows of distance_matrix to match the order of FC_matrix_
distance_matrix <- distance_matrix[rownames(FC_matrix), rownames(FC_matrix)]
dist_matrix <- as.dist(distance_matrix)



if (filter_feature){
  filter_list <- FLVs #GLSs
  filter_id <- FeatureToID(mmo, filter_list)
  filter_id <- filter_id[filter_id %in% rownames(distance_matrix)] # remove custom-annotated but not siriused features
  filter_distance <- mmo$qemistree[filter_id, filter_id]
  heatmap_data <- heatmap_data %>% filter(id %in% filter_id)


  heatmap_data$con <- NULL # as we are looking at FC, all con are 0
  # make matrix for heatmap
  FC_matrix <- as.matrix(heatmap_data[,-1])
  rownames(FC_matrix) <- heatmap_data$id


  # Reorder the rows of distance_matrix to match the order of FC_matrix_
  filter_distance <- filter_distance[rownames(FC_matrix), rownames(FC_matrix)]
  dist_matrix <- as.dist(filter_distance)
  #Label custm-annotated features
  row_label <- rownames(FC_matrix)
  for (i in 1:length(rownames(FC_matrix))){
    id <- rownames(FC_matrix)[i]
    custom_annot <- mmo$custom_annot$custom_annot[mmo$custom_annot$id == id]
    if (length(custom_annot[[1]]) > 0) {
      row_label[i] <- custom_annot[[1]]
    }
  }
}




# 12.2.1.2. Get annotation for Qemistree
#SIRIUS superclass and specific classes
sirius_annot <- mmo$sirius_annot
# Get NPC Annotations
NPC_pathway <- unique(sirius_annot[[30]])[-1] #remove NA
NPC_superclass <- unique(sirius_annot[[32]])[-1] #remove NA
NPC_class <- unique(sirius_annot[[34]])[-1] #remove NA

sirius_annot_qemistry <- sirius_annot %>%
  select(id = 1, NPC_class = 34, NPC_superclass = 32, NPC_pathway = 30) %>%
  filter(id %in% rownames(distance_matrix)) # get features with fingerprints

rownames(sirius_annot_qemistry) <- sirius_annot_qemistry$id
sirius_annot_qemistry$id <- NULL

# 12.2.1.3. Set colors to show in heatmap
ann_colors = list(
    NPC_pathway = c('Alkaloids' = 'purple', 'Carbohydrates' = 'green', 'Polyketides' = 'yellow', 'Terpenoids' = 'orange', 
        'Amino acids and Peptides' = 'blue', 'Shikimates and Phenylpropanoids' = 'red', 'Fatty acids' = 'brown'),
    NPC_class = setNames(viridis(length(NPC_class)), NPC_class),
    NPC_superclass = setNames(viridis(length(NPC_superclass)), NPC_superclass)
    )

##### Specific colors for specific classes of interest
ann_colors$NPC_class['Glucosinolates'] <- 'red'

# 12.2.1.4. Plot
pdf("plots/test.pdf", width = 20, height = 40)
pheatmap(mat = FC_matrix, 
     cluster_rows = TRUE, 
     clustering_distance_rows = dist_matrix, 
     cluster_cols = TRUE, 
     clustering_method = "average", #UPGMA
     show_rownames = TRUE, 
     show_colnames = TRUE,
     annotation_row = sirius_annot_qemistry, # Dataframe with the rownames are identical with 'mat' and gives annotation
     annotation_colors = ann_colors,
     cellwidth = 25,
     cellheight = 0.5,
     treeheight_row = 100,
     fontsize_row = 5,
     fontsize_col = 15,
     scale = 'none',
     annotation_names_row = TRUE,
     color = colorRampPalette(c("blue", "white", "red"))(100))
dev.off()
```

## Chemical diversity
The chemical diversity is one of the key parameters in ecological studies. MMO quantifies the chemical diversity idices using idea from `ChemoDiv` package. The fingerprint distances are treated as phylogenetic diversity as in measuring taxonomic diversity. Alpha diversity can be calculated as following.
```
# 8.1. Alpha diversity
# 8.1.1. unweighted Hill
unweighted_q1 <- GetHillNumbers(mmo, q = 1)
unweighted_q2 <- GetHillNumbers(mmo, q = 2)
# 8.1.2. Functional Hill number without Rao's Q
functional.hill.q1 <- GetFunctionalHillNumber(mmo, normalization = 'None', q = 1)
functional.hill.q2 <- GetFunctionalHillNumber(mmo, normalization = 'None', q = 2)
# 8.1.3. Functional Hill number with Rao's Q standardization
functional.hill.q1.raoQ <- GetFunctionalHillNumberwithRaoQ(mmo, normalization = 'None', q = 1)
functional.hill.q2.raoQ <- GetFunctionalHillNumberwithRaoQ(mmo, normalization = 'None', q = 2)
```
Then can be plotted as 
```
ggplot(functional.hill.q1, aes(x = group, y = hill_number)) +
  geom_boxplot(outlier.shape = NA) +
  geom_beeswarm(size = 0.5) +
  theme_classic() 
```
The beta diversity (pairwise sample-sample distance) can be calculated as following:
```
# Generalized UniFrac distance using fingerprint distance. The alpha value can be adjusted
feature <- mmo$zscore
metadata <- mmo$metadata
guni <- GetBetaDiversity(mmo, method = 'Gen.Uni', normalization = 'Log')
guni.0 <- guni[,,'d_0'] # GUniFrac with alpha 0
guni.05 <- guni[,,'d_0.5'] # GUniFrac with alpha 0.5
guni.1 <- guni[,,'d_1'] # Weighted UniFrac
```
To visualize the beta diversity, a NMDS plot can be used
```

# Perform NMDS
nmds <- metaMDS(guni.1, k = 2, try = 50, trymax = 100)
nmds_coords <- as.data.frame(scores(nmds))
groups <- c()
for (col in colnames(feature)[-c(1, 2)]) {
  groups <- append(groups, metadata[metadata$sample == col, ]$group)
}
nmds_coords$group <- groups
ggplot(nmds_coords, aes(x = NMDS1, y = NMDS2, color = group)) +
      geom_point(size = 3) +
      #geom_text_repel(aes(label = group), size = 3) +
      theme_classic() +
      stat_ellipse(level = 0.90) +
      labs(x = "NMDS1", y = "NMDS2") +
      theme(legend.position = "right")
```


## Performance Regression for finding resistance features
We are interested in finding anti-herbivore resistive compounds from the plant metabolome and testing whether such compounds are upregulated by insect attack. To do so, we first fit linear mixed model to the amount of each feature and the herbivore performance fed on each plant sample (see metadata). The negative effect size of the model represents the resistive value of the feature. We then test whether resistive features are upregulated (log2FC > 1) by plotting the effect size of the LMM and the log2FC as scatter plot. In the demo file, resistive compounds (which have neative effect sizes) were upregulated, which implies plants produce resistive compounds properly in response to sl attack. The analysis can be done as follows:
```
# fetch pairwise comparisons from mmo$pairwise
comparisons <- c('con_vs_sl1', 'con_vs_sl2', 'con_vs_sl3', 'con_vs_px1', 'con_vs_px2', 'con_vs_px3', 'con_vs_le1', 'con_vs_le2', 'con_vs_le3')
# Define the DAMs
sl.up <- Reduce(union, c(
  DAMs_up$con_vs_sl1.up, 
  DAMs_up$con_vs_sl2.up, 
  DAMs_up$con_vs_sl3.up
))
sl.down <- Reduce(union, c(
  DAMs_down$con_vs_sl1.down, 
  DAMs_down$con_vs_sl2.down, 
  DAMs_down$con_vs_sl3.down
))

# Fit LMM and find significant features
sl.lmm <- GetPerformanceFeatureLMM(mmo, herbivore = 'Sl', groups = c('sl1', 'sl2', 'sl3'), DAM.list = list(sl.up = sl.up, sl.down = sl.down), comparisons)
sl.lmm.sig <- sl.lmm %>% filter(p_value < 0.05)
sl.lmm.sig.neg <- sl.lmm.sig %>% filter(effect.size < 0)
# Plot the association between fold change and effect size
PlotFoldchangeResistanceRegression(performance_regression = sl.lmm.sig, 
  fold_change = 'con_vs_sl3_log2FC', 
  color = c('sl.up' = '#ba3b3c', 'sl.down' = '#1a3f9e', 'else' = 'grey'), 
  output_dir = 'plots/sl_lmm.png')
```
